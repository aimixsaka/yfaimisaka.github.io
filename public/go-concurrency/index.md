# Go并发经验


## $ 前言

记录一下go并发的实践经验

### $ 内容

- 当出现死锁时，考虑是否已用`make`将声明的`chan`初始化
- 永远在**不同的**`goroutine`中发送和接收`chan`中的值，不要试图在main中发送并接收值
- 如果`chan`是**无缓冲的**，总是**先**运行一个`goroutine`来发送或接收值，**然后**再在main(或其它`goroutine`)中接收或发送
- 想要在`main`中同时收发`chan`中的值，考虑使用**缓冲通道**
- 总是考虑**两个互相收发**的`chan`之间造成的死锁问题(比如两个`chan`同时发送给对方，此时没有人接收)，可以通过将一个发送操作放在单独的`goroutine`中来解决
- 其他`goroutine`的阻塞完全不会影响到`主goroutine`
- 考虑用`close`关闭`chan`来广播的技巧
- 注意**全局变量**引起的**数据竞态**问题，指全局变量可能被**多个goroutine同时读写**(至少一个写入)。优先使用局部变量，或使用只读全局变量
