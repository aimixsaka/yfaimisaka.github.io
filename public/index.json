[{"categories":["Go"],"content":"\r$ Go是什么\r引用\rGo（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言 主要创始人是罗伯特·格瑞史莫、罗勃·派克及肯·汤普逊 ​ – 维基百科 Go ","date":"2022-09-25","objectID":"/go-overview/:1:0","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-go是什么"},{"categories":["Go"],"content":"\r$ Go的优点 以 “少即是多” 为理念，语法简洁，容易上手 语法和结构类C （C是世界上最好的语言 😊 内置高并发 （你不觉得同时做一千万件事很酷cool吗 😏 内置支持UTF-8 适用于云开发，web后端， 面向对象，函数式… …… ","date":"2022-09-25","objectID":"/go-overview/:2:0","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-go的优点"},{"categories":["Go"],"content":"\r$ Go怎么学","date":"2022-09-25","objectID":"/go-overview/:3:0","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-go怎么学"},{"categories":["Go"],"content":"\r$ 前言其实学Go最好的地方就是Go官网 ","date":"2022-09-25","objectID":"/go-overview/:3:1","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-前言"},{"categories":["Go"],"content":"\r$ 入门 Tour of Go English | 中文 Go官方的入门之旅。看完就基本学完了Go的所有语法（就是这么简洁与简单 Learn X in Y Minutes English | 中文 ","date":"2022-09-25","objectID":"/go-overview/:3:2","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-入门"},{"categories":["Go"],"content":"\r$ 初识Go的并发 Go Concurrency Patterns Rob Pike(Go的3个主要创始人之一) 的一场关于Go的并发模式的演讲，Google I/O 2012 ","date":"2022-09-25","objectID":"/go-overview/:3:3","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-初识go的并发"},{"categories":["Go"],"content":"\r$ 更进一步了解Go Go Programming 另一场演讲，Google I/O 2010 《Go程序设计语言》 Go领域公认的 “圣经” （建议直接买纸质书 Meet The Go Team Go团队就一些Go设计问题的现场提问与回答 （重点是看大佬 ：） 高性能Go 对如何提高go的性能方面进行了研究 Go方面较为全面的文摘 ","date":"2022-09-25","objectID":"/go-overview/:3:4","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-更进一步了解go"},{"categories":["Go"],"content":"\r$ Go的未来尽管Go非常优秀（ (;¬_¬) 不准质疑），但是Go也有美中不足的地方，比如Go的错误处理 但是Go在不断改善（以每三个月一次小版本的形式，尤其是即将到来的Go2充满了令人激动的特性 Go2的一些草案 让我们充满期待…(* ^ ω ^) Go ","date":"2022-09-25","objectID":"/go-overview/:4:0","series":null,"tags":["Go","入门"],"title":"Go 概览","uri":"/go-overview/#-go的未来"},{"categories":["Go"],"content":"\r$ 前言记录一下go并发的实践经验 ","date":"2022-07-29","objectID":"/go-concurrency/:1:0","series":null,"tags":["Go","并发"],"title":"Go并发经验","uri":"/go-concurrency/#-前言"},{"categories":["Go"],"content":"\r$ 内容 当出现死锁时，考虑是否已用make将声明的chan初始化 永远在不同的goroutine中发送和接收chan中的值，不要试图在main中发送并接收值 如果chan是无缓冲的，总是先运行一个goroutine来发送或接收值，然后再在main(或其它goroutine)中接收或发送 想要在main中同时收发chan中的值，考虑使用缓冲通道 总是考虑两个互相收发的chan之间造成的死锁问题(比如两个chan同时发送给对方，此时没有人接收)，可以通过将一个发送操作放在单独的goroutine中来解决 其他goroutine的阻塞完全不会影响到主goroutine 考虑用close关闭chan来广播的技巧 注意全局变量引起的数据竞态问题，指全局变量可能被多个goroutine同时读写(至少一个写入)。优先使用局部变量，或使用只读全局变量 ","date":"2022-07-29","objectID":"/go-concurrency/:1:1","series":null,"tags":["Go","并发"],"title":"Go并发经验","uri":"/go-concurrency/#-内容"},{"categories":["Go"],"content":"\r$ 前言记录一下go中的请求和响应处理 ","date":"2022-07-30","objectID":"/go-request-responce/:1:0","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-前言"},{"categories":["Go"],"content":"\r$ 请求","date":"2022-07-30","objectID":"/go-request-responce/:2:0","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-请求"},{"categories":["Go"],"content":"\r$ Request结构 Request结构既可以用于客户端也可以用于服务端 Request结构 type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). Method string URL *url.URL /*#*/ Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Request Header Header Header /*#*/ // Request Body Body io.ReadCloser /*#*/ // return a new copy of Body // used for client requests // For server requests, it is unused GetBody func() (io.ReadCloser, error) // value -1 indicates that the length is unknown // Values \u003e= 0 indicate that the given number of bytes may // be read from Body ContentLength int64 TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // thisis either the value of the \"Host\" header // or the host namegiven in the URL itself Host string // including both the URL field's query parameters // and the PATCH, POST, or PUT form data Form url.Values /*#*/ // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters PostForm url.Values /*#*/ // MultipartForm is the parsed multipart form, including file uploads MultipartForm *multipart.Form /*#*/ // Trailer specifies additional headers // that are sent after the request body Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel \u003c-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response } $ URL字段 URL结构体 type URL struct { Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string } URL的一般结构 scheme://[ userinfo@]host/path[$query][#fragment] $ Header字段 一个 首部就是一个映射， 这个映射的键为字符串， 值为字符串切片 $ 获取和设置或修改Header中字段 通过切片访问Header中的特定字段，返回切片 w.Header[\"Accept-Encodeing\"] 结果：[gzip, deflate] 通过Get和Set方法，Get返回逗号分隔的字符串 w.Header.Get(\"Accept-Encodeing\") 结果：gzip, deflate $ Body字段 Body是一个ReadCloser 接口， 该接口既包含了Reader接口，也包含了Closer接口 一个例子 package main import ( \"fmt\" \"net/http\" ) func body(w http.ResponseWriter, r *http.Request) { len := r.ContentLength body := make([]byte, len) r.Body.Read(body) fmt.Fprintln(w, string(body)) } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/body\", body) server.ListenAndServe() } ","date":"2022-07-30","objectID":"/go-request-responce/:2:1","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-request结构"},{"categories":["Go"],"content":"\r$ Request结构 Request结构既可以用于客户端也可以用于服务端 Request结构 type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). Method string URL *url.URL /*#*/ Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Request Header Header Header /*#*/ // Request Body Body io.ReadCloser /*#*/ // return a new copy of Body // used for client requests // For server requests, it is unused GetBody func() (io.ReadCloser, error) // value -1 indicates that the length is unknown // Values \u003e= 0 indicate that the given number of bytes may // be read from Body ContentLength int64 TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // thisis either the value of the \"Host\" header // or the host namegiven in the URL itself Host string // including both the URL field's query parameters // and the PATCH, POST, or PUT form data Form url.Values /*#*/ // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters PostForm url.Values /*#*/ // MultipartForm is the parsed multipart form, including file uploads MultipartForm *multipart.Form /*#*/ // Trailer specifies additional headers // that are sent after the request body Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel \u003c-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response } $ URL字段 URL结构体 type URL struct { Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string } URL的一般结构 scheme://[ userinfo@]host/path[$query][#fragment] $ Header字段 一个 首部就是一个映射， 这个映射的键为字符串， 值为字符串切片 $ 获取和设置或修改Header中字段 通过切片访问Header中的特定字段，返回切片 w.Header[\"Accept-Encodeing\"] 结果：[gzip, deflate] 通过Get和Set方法，Get返回逗号分隔的字符串 w.Header.Get(\"Accept-Encodeing\") 结果：gzip, deflate $ Body字段 Body是一个ReadCloser 接口， 该接口既包含了Reader接口，也包含了Closer接口 一个例子 package main import ( \"fmt\" \"net/http\" ) func body(w http.ResponseWriter, r *http.Request) { len := r.ContentLength body := make([]byte, len) r.Body.Read(body) fmt.Fprintln(w, string(body)) } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/body\", body) server.ListenAndServe() } ","date":"2022-07-30","objectID":"/go-request-responce/:2:1","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-url字段"},{"categories":["Go"],"content":"\r$ Request结构 Request结构既可以用于客户端也可以用于服务端 Request结构 type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). Method string URL *url.URL /*#*/ Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Request Header Header Header /*#*/ // Request Body Body io.ReadCloser /*#*/ // return a new copy of Body // used for client requests // For server requests, it is unused GetBody func() (io.ReadCloser, error) // value -1 indicates that the length is unknown // Values \u003e= 0 indicate that the given number of bytes may // be read from Body ContentLength int64 TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // thisis either the value of the \"Host\" header // or the host namegiven in the URL itself Host string // including both the URL field's query parameters // and the PATCH, POST, or PUT form data Form url.Values /*#*/ // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters PostForm url.Values /*#*/ // MultipartForm is the parsed multipart form, including file uploads MultipartForm *multipart.Form /*#*/ // Trailer specifies additional headers // that are sent after the request body Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel \u003c-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response } $ URL字段 URL结构体 type URL struct { Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string } URL的一般结构 scheme://[ userinfo@]host/path[$query][#fragment] $ Header字段 一个 首部就是一个映射， 这个映射的键为字符串， 值为字符串切片 $ 获取和设置或修改Header中字段 通过切片访问Header中的特定字段，返回切片 w.Header[\"Accept-Encodeing\"] 结果：[gzip, deflate] 通过Get和Set方法，Get返回逗号分隔的字符串 w.Header.Get(\"Accept-Encodeing\") 结果：gzip, deflate $ Body字段 Body是一个ReadCloser 接口， 该接口既包含了Reader接口，也包含了Closer接口 一个例子 package main import ( \"fmt\" \"net/http\" ) func body(w http.ResponseWriter, r *http.Request) { len := r.ContentLength body := make([]byte, len) r.Body.Read(body) fmt.Fprintln(w, string(body)) } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/body\", body) server.ListenAndServe() } ","date":"2022-07-30","objectID":"/go-request-responce/:2:1","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-header字段"},{"categories":["Go"],"content":"\r$ Request结构 Request结构既可以用于客户端也可以用于服务端 Request结构 type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). Method string URL *url.URL /*#*/ Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Request Header Header Header /*#*/ // Request Body Body io.ReadCloser /*#*/ // return a new copy of Body // used for client requests // For server requests, it is unused GetBody func() (io.ReadCloser, error) // value -1 indicates that the length is unknown // Values \u003e= 0 indicate that the given number of bytes may // be read from Body ContentLength int64 TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // thisis either the value of the \"Host\" header // or the host namegiven in the URL itself Host string // including both the URL field's query parameters // and the PATCH, POST, or PUT form data Form url.Values /*#*/ // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters PostForm url.Values /*#*/ // MultipartForm is the parsed multipart form, including file uploads MultipartForm *multipart.Form /*#*/ // Trailer specifies additional headers // that are sent after the request body Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel \u003c-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response } $ URL字段 URL结构体 type URL struct { Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string } URL的一般结构 scheme://[ userinfo@]host/path[$query][#fragment] $ Header字段 一个 首部就是一个映射， 这个映射的键为字符串， 值为字符串切片 $ 获取和设置或修改Header中字段 通过切片访问Header中的特定字段，返回切片 w.Header[\"Accept-Encodeing\"] 结果：[gzip, deflate] 通过Get和Set方法，Get返回逗号分隔的字符串 w.Header.Get(\"Accept-Encodeing\") 结果：gzip, deflate $ Body字段 Body是一个ReadCloser 接口， 该接口既包含了Reader接口，也包含了Closer接口 一个例子 package main import ( \"fmt\" \"net/http\" ) func body(w http.ResponseWriter, r *http.Request) { len := r.ContentLength body := make([]byte, len) r.Body.Read(body) fmt.Fprintln(w, string(body)) } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/body\", body) server.ListenAndServe() } ","date":"2022-07-30","objectID":"/go-request-responce/:2:1","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-获取和设置或修改header中字段"},{"categories":["Go"],"content":"\r$ Request结构 Request结构既可以用于客户端也可以用于服务端 Request结构 type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). Method string URL *url.URL /*#*/ Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Request Header Header Header /*#*/ // Request Body Body io.ReadCloser /*#*/ // return a new copy of Body // used for client requests // For server requests, it is unused GetBody func() (io.ReadCloser, error) // value -1 indicates that the length is unknown // Values \u003e= 0 indicate that the given number of bytes may // be read from Body ContentLength int64 TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // thisis either the value of the \"Host\" header // or the host namegiven in the URL itself Host string // including both the URL field's query parameters // and the PATCH, POST, or PUT form data Form url.Values /*#*/ // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters PostForm url.Values /*#*/ // MultipartForm is the parsed multipart form, including file uploads MultipartForm *multipart.Form /*#*/ // Trailer specifies additional headers // that are sent after the request body Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel \u003c-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response } $ URL字段 URL结构体 type URL struct { Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string } URL的一般结构 scheme://[ userinfo@]host/path[$query][#fragment] $ Header字段 一个 首部就是一个映射， 这个映射的键为字符串， 值为字符串切片 $ 获取和设置或修改Header中字段 通过切片访问Header中的特定字段，返回切片 w.Header[\"Accept-Encodeing\"] 结果：[gzip, deflate] 通过Get和Set方法，Get返回逗号分隔的字符串 w.Header.Get(\"Accept-Encodeing\") 结果：gzip, deflate $ Body字段 Body是一个ReadCloser 接口， 该接口既包含了Reader接口，也包含了Closer接口 一个例子 package main import ( \"fmt\" \"net/http\" ) func body(w http.ResponseWriter, r *http.Request) { len := r.ContentLength body := make([]byte, len) r.Body.Read(body) fmt.Fprintln(w, string(body)) } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/body\", body) server.ListenAndServe() } ","date":"2022-07-30","objectID":"/go-request-responce/:2:1","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-body字段"},{"categories":["Go"],"content":"\r$ Go与HTML表单\r$ HTML表单的一般形式 \u003cform action=\"/process\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"\u003e \u003cinput type=\"text\" name=\"first_name\"/\u003e \u003cinput type=\"text\" name=\"last_name\"/\u003e \u003cinput type=\"submit\"/\u003e \u003c/form\u003e $ 数据编码方式 application/x-www-form-urlencoded 将HTML中表单中的数据编码为连续的长查询字符串 multipart/form-data 将表单中的数据转换为一条MIME报文，表单中的每个键值对都构成了这条报文的一部分 text/plain HTML5支持 如何选择 $ application/x-www-form-urlencoded （简单文本数据 multipart/form-data （传输大量数据，如上传文件 text/plain （``Base64`编码，文本方式传输二进制数据 ","date":"2022-07-30","objectID":"/go-request-responce/:2:2","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-go与html表单"},{"categories":["Go"],"content":"\r$ Go与HTML表单\r$ HTML表单的一般形式 $ 数据编码方式 application/x-www-form-urlencoded 将HTML中表单中的数据编码为连续的长查询字符串 multipart/form-data 将表单中的数据转换为一条MIME报文，表单中的每个键值对都构成了这条报文的一部分 text/plain HTML5支持 如何选择 $ application/x-www-form-urlencoded （简单文本数据 multipart/form-data （传输大量数据，如上传文件 text/plain （``Base64`编码，文本方式传输二进制数据 ","date":"2022-07-30","objectID":"/go-request-responce/:2:2","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-html表单的一般形式"},{"categories":["Go"],"content":"\r$ Go与HTML表单\r$ HTML表单的一般形式 $ 数据编码方式 application/x-www-form-urlencoded 将HTML中表单中的数据编码为连续的长查询字符串 multipart/form-data 将表单中的数据转换为一条MIME报文，表单中的每个键值对都构成了这条报文的一部分 text/plain HTML5支持 如何选择 $ application/x-www-form-urlencoded （简单文本数据 multipart/form-data （传输大量数据，如上传文件 text/plain （``Base64`编码，文本方式传输二进制数据 ","date":"2022-07-30","objectID":"/go-request-responce/:2:2","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-数据编码方式"},{"categories":["Go"],"content":"\r$ 表单的解析\r$ 手动解析 application/x-www-form-urlencoded编码 先调用w.ParseForm()方法 通过w.Form字段访问表单数据和URL参数 或者通过w.PostForm字段实现只访问表单数据 multipart/form-data编码 先调用w.ParseMultipartForm()方法 通过w.MultipartForm字段访问表单数据或获取上传的文件 $ 自动解析 FormValue(key string) PostFormValue(key string) 这两个方法会自动调用ParseForm()和ParseMultipartForm()方法进行解析 注：如果对应该键的值不止一个，方法只返回第一个值 ","date":"2022-07-30","objectID":"/go-request-responce/:2:3","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-表单的解析"},{"categories":["Go"],"content":"\r$ 表单的解析\r$ 手动解析 application/x-www-form-urlencoded编码 先调用w.ParseForm()方法 通过w.Form字段访问表单数据和URL参数 或者通过w.PostForm字段实现只访问表单数据 multipart/form-data编码 先调用w.ParseMultipartForm()方法 通过w.MultipartForm字段访问表单数据或获取上传的文件 $ 自动解析 FormValue(key string) PostFormValue(key string) 这两个方法会自动调用ParseForm()和ParseMultipartForm()方法进行解析 注：如果对应该键的值不止一个，方法只返回第一个值 ","date":"2022-07-30","objectID":"/go-request-responce/:2:3","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-手动解析"},{"categories":["Go"],"content":"\r$ 表单的解析\r$ 手动解析 application/x-www-form-urlencoded编码 先调用w.ParseForm()方法 通过w.Form字段访问表单数据和URL参数 或者通过w.PostForm字段实现只访问表单数据 multipart/form-data编码 先调用w.ParseMultipartForm()方法 通过w.MultipartForm字段访问表单数据或获取上传的文件 $ 自动解析 FormValue(key string) PostFormValue(key string) 这两个方法会自动调用ParseForm()和ParseMultipartForm()方法进行解析 注：如果对应该键的值不止一个，方法只返回第一个值 ","date":"2022-07-30","objectID":"/go-request-responce/:2:3","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-自动解析"},{"categories":["Go"],"content":"\r$ 文件上传和接收举个例子 HTML表单 \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\" text/html; charset=utf-8\"/\u003e \u003c title\u003eGo Web Programming\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:8080/process$hello=world\u0026thread=123\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"text\" name=\"hello\" value=\"sau sheong\"/\u003e \u003cinput type=\"text\" name=\"post\" value=\"456\"/\u003e \u003cinput type=\"file\" name=\"uploaded\"/\u003e \u003cinput type=\"submit\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e Go处理 package main import( \"fmt\" \"io/util\" \"net/http\" ) func process(w http.ResponseWriter, r *http.Request) { r.ParseMultipartForm(1024) fileHeader := r.MultipartForm.File(\"uploaded\")[0] file, err := fileHeader.Open() if err == nil { data, err := ioutil.ReadAll(file) if err == nil { fmt.Fprintln(w, string(data)) } } } func main() { server := http.Server{ Addr: \"127.0.0.1\" } http.HandleFunc(\"/process\", process) server.ListenAndServe() } 或者用FormFile()方法 func process(w http.ResponseWriter, r *http.Request) { file, _, err := r.FormFile(\"uploaded\") if err == nil { data, err := ioutil.ReadAll(file) if err == nil { fmt.Fprintln(w, string(data)) } } } 当文件只有一个时这特别有用 ","date":"2022-07-30","objectID":"/go-request-responce/:2:4","series":null,"tags":["Go","Web"],"title":"Go中的请求和响应","uri":"/go-request-responce/#-文件上传和接收"},{"categories":["Go"],"content":"\r$ 前言最近看了下Go Web编程这本书，再去看了下源码，想对net/http包中的一些关键的函数，接口的定义和关系做一个记录 ","date":"2022-07-30","objectID":"/go-web/:1:0","series":null,"tags":["Go","Web"],"title":"Go Web编程","uri":"/go-web/#-前言"},{"categories":["Go"],"content":"\r$ 多路复用器 Go中web应用需要对客户端的请求响应，为了将不同请求URL转发到不同的处理器(Handler)进行处理需要用到多路复用器(ServeMux) (var) DefaultServeMux: ListenAndServe(string, Handler) error 中第二个参数的默认值，实质是一个指向ServeMux类型的指针，是ServeMux的一个实例，但ServeMux同时又实现了Handler接口(故可以充当第二个参数的默认值) 源码: // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = \u0026defaultServeMux var defaultServeMux ServeMux (func) NewServeMux(): 返回一个ServeMux (struct) ServeMux: 多路复用器结构，负责URL的路径和处理的映射，以及通过自身的ServeHTTP方法调用URL映射对应的处理器的ServeHTTP方法 源码: type ServeMux struct { mu sync.RWMutex m map[string]muxEntry es []muxEntry // slice of entries sorted from longest to shortest. hosts bool // whether any patterns contain hostnames } ","date":"2022-07-30","objectID":"/go-web/:1:1","series":null,"tags":["Go","Web"],"title":"Go Web编程","uri":"/go-web/#-多路复用器"},{"categories":["Go"],"content":"\r$ 服务器 负责启动监听和配置服务 如果简单配置可以直接调http.ListenAndServe函数来进行监听，复杂配置则需要构建一个Server结构体来调用其ListenAndServe方法 (struct) Server: 用于细化配置的结构体 源码: type Server struct { Addr string Handler Handler TLSConfig *tls.Config ReadTimeout time.Duration ReadHeaderTimeout time.Duration WriteTimeout time.Duration IdleTimeout time.Duration MaxHeaderBytes int TLSNextProto map[string]func(*Server, *tls.Conn, Handler) ConnState func(net.Conn, ConnState) ErrorLog *log.Logger BaseContext func(net.Listener) context.Context ConnContext func(ctx context.Context, c net.Conn) context.Context } (func) ListenAndServe(addr string, handler Handler) error: 开启监听和进行处理，是整个web应用的启动器 (func) ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error: ListenAndServe的https版本 ","date":"2022-07-30","objectID":"/go-web/:1:2","series":null,"tags":["Go","Web"],"title":"Go Web编程","uri":"/go-web/#--服务器"},{"categories":["Go"],"content":"\r$ 处理器和处理器函数 Go web中实际处理请求的函数或类型 处理器：实现了Handler接口的任意类型，可以是结构体，函数类型等 处理器函数：普通的函数，但是必须要以 http.ResponseWriter和*http.Request为参数 (interface) Handler {ServeHTTP(ResponseWriter, *Request)}: 处理器接口，实现了该接口的即为处理器 (func) http.Handle(pattern string, handler Handler): 将Handler和DefaultServeMux (或自定义的ServeMux) 绑定，使其处理pattern上的请求。实质是ServeMux的方法，方便调用故在http包中创建。实质: // http.Handle func Handle(pattern string, handler Handleer) { DefaultServeMux.Handle(pattern, handler) } // 在server.go源码中 (func) http.HandleFunc(pattern string, handler func(ResponseWriter, *Request)): 将处理器函数与ServeMux绑定并监听pattern路径。实质会被转换为一个Handler: // http.HandleFunc func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } // ServeMux.HandleFunc func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { mux.Handle(pattern, HandlerFunc(handler)) } // 通过显式类型转换将底层类型相同的handler转换为HandlerFunc类型 // HandlerFunc是个函数类型 type HandlerFunc func(ResponseWriter, *Request) /*并且它实现了Handler接口，也就是说， HandlerFunc类型是个处理器(Handler), 故调用HandleFunc方法实质是调用Handle方法， 且将一个普通函数类型的参数转换成了一个处理器 */ func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } ","date":"2022-07-30","objectID":"/go-web/:1:3","series":null,"tags":["Go","Web"],"title":"Go Web编程","uri":"/go-web/#--处理器和处理器函数"},{"categories":["Java"],"content":"\r$ 前言之前就有个想法把bot用spring重写一下。了解完一些基础的东西后终于能开写了。 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:1:0","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-前言"},{"categories":["Java"],"content":"\r$ 基于注解加反射","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:2:0","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-基于注解加反射"},{"categories":["Java"],"content":"\r$ 推这一点是看了诺天的博客。 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:2:1","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-推"},{"categories":["Java"],"content":"\r$ 思路 写个自定义注解用以标记方法 利用spring自带的SpringUtil.getApplicationContext().getBeansWithAnnotation(Controller.class)来获取所有被@Controller标记的类的bean。 【注： 这里的SpringUtil是你自己的写的任意实现了ApplicationContextAware接口的类的名字。并且注解类型必须是Spring里的注解（@Controller,@Component等，不然获取不到bean 利用反射的相关方法获取所有方法。再做个遍历筛选出带有自定义注解的方法加入一个列表。 监听器中调用这个列表进行逻辑判断，确定什么时候调用并传入方法需要的实参 这样发消息的时候就能实现自动判断并执行 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:2:2","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-思路"},{"categories":["Java"],"content":"\r$ 补充博客里写的已经很详细了。但是总感觉有些功能还可以再补充一下： 逻辑判断和多种权限： 一：诺天写的消息的逻辑判断是放在注解中，再和bot接收到的消息进行对比来实现的。但是这样 逻辑一复杂就会让监听器太冗杂。 二：一个注解只能让一个方法用于Group或Friend，没法多个权限 解决方案： (一)让注解可重复，增加注解元素 @Event注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Events.class) // 元注解，使该注解能重复。@Events是含有 返回Event[] 的方法的注解 public @interface Event { EventEnum eventType() default EventEnum.NONE; // EventEnum是个枚举类 boolean authority() default false; // 第一层判断,是否开启这个方法 boolean judgeByMethod() default false; // 复杂判断时开启这个 String message() default \"\"; // 第二层判断,触发条件 } @Events注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Events { Event[] value(); } 注意@Events注解必须写@Target，且元素类型是@Event的子集 (二)除了message的判断，再在反射时把MessageChain传进去。 复杂的方法把judgeByMethod设为true，让方法利用MessageChain获得消息进行逻辑处理 简单的方法把judgeByMethod设为false，利用message注解元素在监听器中进行equals判断 结果：利用authority和message来灵活分配权限(虽然也不灵活就是了)；judgeByMethod实现判断权限转移 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:2:3","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-补充"},{"categories":["Java"],"content":"\r$ 基于注解和切面编程(Aop)因为Aop是根据反射开发的，于是我想能不能用Aop写一个。 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:3:0","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-基于注解和切面编程aop"},{"categories":["Java"],"content":"\r$ 思路利用Aop对被指定注解标记的方法进行增强。在方法执行前进行一个判断。 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:3:1","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-思路-1"},{"categories":["Java"],"content":"\r$ 代码Aop部分： 类上标注@Aspect注解 // 切入点 实际切入的方法 // 注意是对Events切入，因为多个Event注解其实在获取的时候会转换成@Events({@Event(xx), @Event(xx)}) @PointCut(\"@annotation(com.yanfang.animabotaop.annotations.Events)\") public void judgeMethodPointCut() {} // 切入方法$ // 环绕通知 // \u0026\u0026 @annotation(events)是传入参数给通知方法的一种手段，可以省去声明 // around方法参数名要和@Around中一致 // ProceedingJoinPoint 是环绕通知特有的，是JoinPoint的子接口，其他通知为JoinPoint。 // 该参数的功能很强大 @Around(\"judgeMethodPointCut() \u0026\u0026 @annotation(events)\") public void around(@NotNull ProceedingJoinPoint jpt, @NotNull Events events) throws Throwable { for (Event eventAnnotation : events.value()) { // 获取实参值（注意是“值” Object[] argValues = jpt.getArgs(); // 获取传入的event，这里默认所有方法第一个参数都是MessageEvent MessageEvent event = (MessageEvent) argValues[0]; // 进行逻辑判断，这里和用反射时一样 if (eventAnnotation.authority()) { System.out.println(\"已授权\"); // 有复杂逻辑就将judgeByMethod设为true， 交给方法进行复杂逻辑处理 if (eventAnnotation.judgeByMethod() || (eventAnnotation.message().equals(event.getMessage().contentToString()))) { if (event.getSubject() instanceof Group \u0026\u0026 eventAnnotation.eventType() == EventEnum.GROUPEVENT) { joinPoint.proceed(argValues); } else if (event.getSubject() instanceof Friend \u0026\u0026 eventAnnotation.eventType() == EventEnum.MASTEREVENT) { joinPoint.proceed(argValues); } else if (event.getSubject() instanceof Member \u0026\u0026 eventAnnotation.eventType() == EventEnum.TEMPEVENT) { joinPoint.proceed(argValues); } } } } } 监听器方法方面： @EventHandler public ListeningStatus onMessage(@NotNull MessageEvent event) throws Exception { @NotNull Test test = SpringUtil.getBean(Test.class); test.test(event); return ListeningStatus.LISTENING; } 测试类： @Controller public class Test { @Events(@Event(eventType = EventEnum.MASTEREVENT, authority = true, message = \"test\")) public void test(MessageEvent event) { if (event == null) System.out.println(\"event 为空\"); else event.getSubject().sendMessage(\"get\"); } } 结果： authority为true时发送了get， 为false时没发送get。说明执行了环绕通知 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:3:2","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-代码"},{"categories":["Java"],"content":"\r$ 坑 注意Aop和反射不同的一点是：反射可以帮助传入实参；而Aop只能获取方法被传入的实参进行处理，而不能传入参数（毕竟Aop的原衷是不影响方法本身的情况下进行对方法的增强。 而实参在监听器方法里传入 这里不能通过获取所有Event注解， 再分别进行处理，而需要获取@Events，再通过它的value()元素获取所有的@Event注解 [即使表面上可以在方法上多写几个@Event注解。但实际是@Events({@Event(...), @Event(...)}),但是用反射好像可以直接获取多个@Event注解进行遍历处理 注意通知的方法around()传参不能直接传入，而是需要在@Around中传入。否则会报空。（其实是获取方法上的@Events注解，然后传进around()方法 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:3:3","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-坑"},{"categories":["Java"],"content":"\r$ 比较与总结总的来说，各有优缺。 反射：先进行判断，然后再根据判断结果来决定是否执行方法 Aop：要先调用方法（注意还并没有实际执行），进而会触发通知，用通知中的方法进行逻辑判断 反射代码较多，但是处理上更灵活，不必先调用方法 Aop要先调用方法，才会触发通知，但是代码量更少，更简洁 ","date":"2022-07-29","objectID":"/rewrite-bot-with-aop-and-reflection/:4:0","series":null,"tags":["Java","Aop","QQ bot"],"title":"用aop和注解重写bot","uri":"/rewrite-bot-with-aop-and-reflection/#-比较与总结"},{"categories":null,"content":"\r后端指南\r后端的引路人，有独特的人格魅力 后端指鉴\r立志掌控网络的男人 狠戳这里\r我最敬佩和尊敬的人之一，是傲娇笨蛋 综合训练营\r不只是后端大手子，比较佩服的后端手 美少女集群\rcxy..嘿嘿，是美少女捏 后端全功能大爹\r快来看萌王 后端顶梁\r快来 原 训练人工智能认出你的老婆.jpg\r前端爹，不会，教教 ","date":"2022-08-02","objectID":"/links/:0:0","series":null,"tags":null,"title":"友链","uri":"/links/#"},{"categories":["Python"],"content":"\r$ 前言Python中的一切皆对象。同样函数也是如此。 装饰器（形如@staticmethod, @overload等）其实是一个装饰器函数或一个装饰器类对装饰器装饰的函数的对象的调用再赋值的过程, 表面上体现为以函数对象作为参数。 ","date":"2022-07-30","objectID":"/decorator-in-python/:1:0","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-前言"},{"categories":["Python"],"content":"\r$ 实质\r理解装饰器\r@decorator function_name() # 等价于： function_name = decorator(function_name) #（其中，有这么一个装饰器函数： def decorator(f): @wraps(f) def xxx(xx, xx...): ... # 调用前 return f() # 或者直接f()来调用函数 ... # 调用后 return xxx ","date":"2022-07-30","objectID":"/decorator-in-python/:1:1","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-实质"},{"categories":["Python"],"content":"\r$ 普通装饰器(直接拿菜鸟教程的例子) 示例一： def a_new_decorator(a_func): def wrap_the_function(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return warp_the_function def a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\") a_function_requiring_decoration() # outputs: \"I am the function which needs some decoration to remove my foul smell\" a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) #now a_function_requiring_decoration is wrapped by wrap_the_function() a_function_requiring_decration() #outputs:I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() 用装饰器写 @a_new_decorator def a_function_requring_decoration(): print(\"I am a function which needs some decoration to\" \"remove my foul smell\") a_function_requiring_decoration() # outputs: I am doing some boring work before executing a_func() # I am the function which needs some decoration to remove my foul smell # I am doing some boring work after executing a_func() #the @a_new_decorator is just a short way of saying: a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 特殊点： print(a_function_requiring_decoration.__name__) # Output: wrap_the_function 注意\r并没有输出\"a_function_requiring_decoration\"。而被\"wrap_the_function\"替代了。 解决方案 from functools import wraps def a_new_decorator(a_func): @wrap(a_func) def wrap_the_function(): print(\"I am doing some boring work before execting a_func\") a_func() print(\"I am doing some boring work after exexting a_func()\") return wrap_the_function @a_new_decorator def a_function_requring_decoration(): print(\"I am the function which needs some decoration to \" \"remove my foul smell\") print(a_function_requiring_decoration.__name__) # Output: a_function_requiring_decoration ","date":"2022-07-30","objectID":"/decorator-in-python/:2:0","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-普通装饰器"},{"categories":["Python"],"content":"\r$ 带参数的装饰器 思路： 创建一个包裹函数。在装饰器函数外面包一层。 例： from functools import wraps def logit(logfile=\"out.log\"): def logging_decrator(func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + \"was called\" print(log_string) # 打开lgofile，并写入内容 with open(logfile, \"a\") as f: f.write(log_string + \"\\n\") return func(*args, **kargs) return wrapped_function return logging_decorator @logit() def myfunc1(): pass myfunc1() # Output: myfunc1 was called # 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串 @logit(logfile='func2.log') def myfunc2(): pass myfunc2() # Output: myfunc2 was called # 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串 ","date":"2022-07-30","objectID":"/decorator-in-python/:3:0","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-带参数的装饰器"},{"categories":["Python"],"content":"\r$ 应用场景\r技巧\r授权 日志 ","date":"2022-07-30","objectID":"/decorator-in-python/:4:0","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-应用场景"},{"categories":["Python"],"content":"\r$ 装饰器类 当你想利用装饰器执行不止一个操作时，可以用来类来包装。 例： from functools import wraps class Logit(object): def __init__(self, logfile='out.log'): self.logfile = logfile def __call__(self, func): @wraps(func) def wrapped_function(*args, **kargs): log_string = func.__name__ + \"was called\" print(log_string) # 打开logfile并写入 with open(self.logfile, 'a') as f: f.write(log_string + '\\n') # 现在，发送一个通知 self.notify() return func(*args, **kargs) return wrapped_function def notify(self): # 该类为logit类，什么也不做，交个子类 pass class EmailLogit(Logit): \"\"\" Logit子类,实现日志记录的同时发邮件 \"\"\" def __init__(self, email=\"admin@myproject.com\", *args, **kargs): self.email = email super(EmailLogit, self).__init__(*args, **kargs) def notify(self): # 具体实现 ... # 调用时与装饰器函数类似。使用@Logit ","date":"2022-07-30","objectID":"/decorator-in-python/:5:0","series":null,"tags":["Python","装饰器"],"title":"Python中的装饰器","uri":"/decorator-in-python/#-装饰器类"},{"categories":["Python"],"content":"\r$ 前言yield是Python极其重要的一个关键字，它与Python中的生成器密切相关，然而yield的用法和生成器本身时不时让人困惑… ","date":"2022-07-29","objectID":"/generator-in-python/:1:0","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-前言"},{"categories":["Python"],"content":"\r$ 生成器和yield有什么用 大多数情况下，使用yield都是为了将函数作为生成器使用(yield只能在函数中使用) 当有大量数据需要返回时生成器能够节省内存空间 ","date":"2022-07-29","objectID":"/generator-in-python/:2:0","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-生成器和yield有什么用"},{"categories":["Python"],"content":"\r$ 一些概念","date":"2022-07-29","objectID":"/generator-in-python/:3:0","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-一些概念"},{"categories":["Python"],"content":"\r$ 可迭代对象 Python中的任意对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法，那么它就是一个可迭代对象。 简单说，可迭代对象就是能提供迭代器的任意对象 ","date":"2022-07-29","objectID":"/generator-in-python/:3:1","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-可迭代对象"},{"categories":["Python"],"content":"\r$ 迭代器 任意对象，只要它定义了next（Python2）或__next__方法，那么它就是一个迭代器 ","date":"2022-07-29","objectID":"/generator-in-python/:3:2","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-迭代器"},{"categories":["Python"],"content":"\r$ 迭代 用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代 ","date":"2022-07-29","objectID":"/generator-in-python/:3:3","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-迭代"},{"categories":["Python"],"content":"\r$ 生成器","date":"2022-07-29","objectID":"/generator-in-python/:4:0","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-生成器"},{"categories":["Python"],"content":"\r$ 概念 生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值 你通过遍历来使用它们，要么用一个\"for\"循环，要么将它们传递给任意可以进行迭代的函数（比如next()）或结构 大多数时候生成器是以函数来实现的（当然，类也可以，但函数较为简便）。然而，它们并不返回一个值，而是yield（产生）一个值 ","date":"2022-07-29","objectID":"/generator-in-python/:4:1","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-概念"},{"categories":["Python"],"content":"\r$ 一些例子正常思路的斐波那契: def fab(max): n, a, b = 0, 0, 1 L = [] # 拿一个列表来存数据，提高复用性 while n \u003c max: L.append(b) a, b = b, a + b n = n + 1 return L for n in fab(5): print(n) 这么做会使该函数的内存占用随参数max增大而增加。 生成器类构建的斐波那契: class Fab: def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def __next__(self): if self.n \u003c self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration() for n in Fab(5): print(n) 生成器函数构建的斐波那契: def fab(n): a = b = 1 for i in range(n): yield a a, b = b, a + b ","date":"2022-07-29","objectID":"/generator-in-python/:4:2","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-一些例子"},{"categories":["Python"],"content":"\r$ 一些关于迭代器的内置函数 next() 获取迭代器的下一个值 iter() 以可迭代对象（比如字符串）为参数，返回一个迭代器对象 ","date":"2022-07-29","objectID":"/generator-in-python/:4:3","series":null,"tags":["Python","生成器"],"title":"Python中的生成器","uri":"/generator-in-python/#-一些关于迭代器的内置函数"},{"categories":null,"content":" 您尚未连接生命之源捏 ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线呜呜","uri":"/offline/#"}]